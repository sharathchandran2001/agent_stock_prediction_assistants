Unit Tests Plan

✅ success path with valid API match and valid accounts.

❌ no API match – match_api_endpoint_async returns None.

❌ upstream API failure – simulate httpx.HTTPStatusError.

❌ empty records list

❌ no accounts key inside first record

import pytest
from unittest.mock import AsyncMock, patch, MagicMock
from httpx import AsyncClient, Response, Request
from fastapi import status
from app.main import app  # adjust if your app is mounted differently

sample_input = {
    "step": "Given I fetch QTD accounts"
}

sample_api_result = {
    "api_endpoint": "http://mock-api/accounts"
}

sample_response_data = {
    "records": [
        {
            "accounts": ["ACC123", "ACC456"]
        }
    ]
}


@pytest.mark.asyncio
async def test_success_path():
    with patch("app.routes.resolve_fetch_and_transform.match_api_endpoint_async", new_callable=AsyncMock) as mock_match, \
         patch("httpx.AsyncClient.get", new_callable=AsyncMock) as mock_http:

        mock_match.return_value = sample_api_result

        mock_http.return_value = MagicMock()
        mock_http.return_value.status_code = 200
        mock_http.return_value.json.return_value = sample_response_data
        mock_http.return_value.raise_for_status.return_value = None

        async with AsyncClient(app=app, base_url="http://test") as ac:
            response = await ac.post("/resolve-fetch-and-transform", json=sample_input)

        assert response.status_code == 200
        assert response.json()["data"] == ["ACC123", "ACC456"]


@pytest.mark.asyncio
async def test_no_api_match():
    with patch("app.routes.resolve_fetch_and_transform.match_api_endpoint_async", new_callable=AsyncMock) as mock_match:
        mock_match.return_value = None

        async with AsyncClient(app=app, base_url="http://test") as ac:
            response = await ac.post("/resolve-fetch-and-transform", json=sample_input)

        assert response.status_code == 404
        assert "No matching API endpoint" in response.text


@pytest.mark.asyncio
async def test_upstream_http_error():
    with patch("app.routes.resolve_fetch_and_transform.match_api_endpoint_async", new_callable=AsyncMock) as mock_match, \
         patch("httpx.AsyncClient.get") as mock_http:

        mock_match.return_value = sample_api_result
        error_response = Response(500, request=Request("GET", sample_api_result["api_endpoint"]))
        mock_http.side_effect = httpx.HTTPStatusError("Upstream error", request=error_response.request, response=error_response)

        async with AsyncClient(app=app, base_url="http://test") as ac:
            response = await ac.post("/resolve-fetch-and-transform", json=sample_input)

        assert response.status_code == 500
        assert "Upstream service error" in response.text


@pytest.mark.asyncio
async def test_empty_records():
    with patch("app.routes.resolve_fetch_and_transform.match_api_endpoint_async", new_callable=AsyncMock) as mock_match, \
         patch("httpx.AsyncClient.get", new_callable=AsyncMock) as mock_http:

        mock_match.return_value = sample_api_result
        mock_http.return_value.status_code = 200
        mock_http.return_value.json.return_value = {"records": []}
        mock_http.return_value.raise_for_status.return_value = None

        async with AsyncClient(app=app, base_url="http://test") as ac:
            response = await ac.post("/resolve-fetch-and-transform", json=sample_input)

        assert response.status_code == 404
        assert "QTD Accounts are not available" in response.text


@pytest.mark.asyncio
async def test_no_accounts_key():
    with patch("app.routes.resolve_fetch_and_transform.match_api_endpoint_async", new_callable=AsyncMock) as mock_match, \
         patch("httpx.AsyncClient.get", new_callable=AsyncMock) as mock_http:

        mock_match.return_value = sample_api_result
        mock_http.return_value.status_code = 200
        mock_http.return_value.json.return_value = {"records": [{}]}
        mock_http.return_value.raise_for_status.return_value = None

        async with AsyncClient(app=app, base_url="http://test") as ac:
            response = await ac.post("/resolve-fetch-and-transform", json=sample_input)

        assert response.status_code == 200
        assert response.json()["data"] == []  # safely handled as no 'accounts' key
